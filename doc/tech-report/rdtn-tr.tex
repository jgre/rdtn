\documentclass{article}

\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{times}

\bibliographystyle{plain}

\begin{document}

\title{RDTN: A DTN Bundle Protcol Agent implemented in Ruby}

\author{Janico Greifenberg}

\maketitle

\begin{abstract}

RDTN is a DTN bundle protocol agent (BPA) implementation written in Ruby. RDTN
is light-weight and flexible so that it can be used in DTN application and
protocol development as well as in research of DTN-related topics such as
routing or convergence-layers. 

RDTN provides a language-independent interface for client application, an
interactive environment for tests and a simulation mode for running multiple
instances of the RDTN code in a simulated network environment. RDTN implements
the bundle protocol (RFC 5050), convergence-layer adapters for TCP, UDP, and
FLUTE, and static and epidemic routing as well as the DTN Publish/Subscribe
Protocol (DPSP).

\end{abstract}

\section{Introduction}\label{sec.intro}

We designed RDTN with the goal to create a platform for DTN research.  We want a
simple implementation of the bundle protocol which can be easily and quickly
extended for experiments of DTN-related research topics from convergence layers
to applications. Another goal for RDTN is to make it usable, robust, and
portable so that it can be used in field tests of DTNs with actual mobile
devices.

RDTN is not supposed to be a reference implementation of the DTN bundle
protocol, the aspect of extensibility and easy experimentation is more important
in its design than the completeness of the protocol implementation.

The fundamental design choice for RDTN is the choice of
Ruby\footnote{http://www.ruby-lang.org} as implementation language. Ruby is a
dynamic programming language that allows simple and concise solutions to a wide
range of programming problems. As Ruby programs do not have to be compiled
explicitly before running them, extensions can be added by simply loading
additional code into an RDTN process. Thus, RDTN does not require a mechanism
for attaching extension in external processes. The dynamic type system allows
extensions a greater flexibility than a static system would.

Another central concept of RDTN is the loose coupling of its components. The
term component in case refers to conceptual units of RDTN, e.g.  routing,
persistent storage, or convergence layers. A component may be realized in
different classes that can be complementary (such as convergence layers for TCP
and UDP) or exclusive (such as implementations of different routing protocols).
When the state of a component changes in such a way that is relevant to other
components (e.g. a convergence layer detects that the connection to another
bundle router is broken), it creates an event that is broadcast to all
interested in this incident (e.g. a lost link can be relevant for the contact
management and routing components). The component sending an event does not need
to know which components are interested in the event. A convergence layer, e.g.,
does not need a reference to the routing algorithm currently used.

This document provides a detailed description of how RDTN implements the bundle
protocol and complementary tasks such as routing. We also describe possible uses
of RDTN, but this text is not meant to serve as a manual for the use of RDTN.

The following two sections cover global aspects of RDTN: section \ref{sec.arch}
discusses the architectural choices of RDTN and the roll of the different
components and section \ref{sec.genparser} describes the generic parser that is
employed in RDTN wherever data from the network needs to be parsed.

Sections \ref{sec.cl} through \ref{sec.config} describe each of the components
of RDTN.  The implementation of convergence layers that DTN bundle protocol
agents use to transmit bundles over lower layer protocols is described in
section \ref{sec.cl}. Section \ref{sec.bundle-proc} covers the implementation of
bundle objects and the processing steps bundles are subjected to. The contact
management mechanisms used in RDTN to determine which other DTN nodes are
available is documented in section \ref{sec.contact-mngt}. The routing schemes
that are available and how further schemes can be implemented is described in
section \ref{sec.routing}. Section \ref{sec.storage} discusses the component for
persistent storage. The interface between RDTN and applications using it is the
subject of \ref{sec.appif}. Section \ref{sec.config} briefly discusses how RDTN
handles its configuration.

The last part of this document discusses the use of RDTN as a research platform.
Section \ref{sec.sim} explains the discrete event simulator integrated in RDTN
and in section \ref{sec.extending} we describe how RDTN can be extended with
routing protocols, storage schemes, convergence layers etc. Section
\ref{sec.conclusions} concludes this technical report and highlights directions
for future work.

\section{Architecture}\label{sec.arch}

Events are distributed between the components by an event dispatcher. This
functionality is implemented in the class {\tt EventDispatcher}. An RDTN bundle
router has one instance of this class and all components have a reference to it.
The event dispatcher implements a simple mechanism for sending named events and
subscribing to them.  This event mechanism allows extension to to notified of
the state of any component without the component being aware of the extension.

An event is identified by a Ruby symbol. The event dispatcher uses this
identifier to map an event to all subscribing components. Events can have
arbitrary arguments, which the dispatcher passes indiscriminately from source to
sink.

When a component subscribes to an event, it passes the event identifier and a
Ruby block to the event dispatcher. Each time the event is triggered, the event
dispatcher, executes the block, passing all the event's parameters.  The event
dispatcher does not implement any threading behaviour itself, so that event
handlers are executed in the thread in which the event was created.

RDTN uses threads to be able to handle multiple tasks that can block, such as IO
functions or timer triggered operations. Although multi-threading comes with the
risk of concurrency problems, we decided against using the {\tt select}-call for
IO multiplexing, because it is not portable. Neither did we want to use a higher
level multiplexing mechanism to avoid having any dependencies besides the Ruby
standard library. The threaded approach allows implementers of extensions to use
any scheme for multiplexing they deem appropriate as long as it is thread-save.

A new thread is started for each task that may block. These tasks include
waiting for incoming connections and data in convergence layers, sending data,
and time-triggered functions, such as deleting expired bundles.

\section{Generic Parser}\label{sec.genparser}

\section{Convergence Layers}\label{sec.cl}

Convergence layers (CLs) define how the bundle protocol can be used over lower
layer protocols. RDTN implements CLs for TCP \cite{dtn-tcp-cl}, UDP\footnote{The UDP
convergence layer has no specification. Our current implementation simply sends
bundles as UDP datagrams}, and FLUTE \cite{uni-dtn}.

Moreover, RDTN implements special CLs for simulations (see section
\ref{sec.sim}) and for the application interface (see section \ref{sec.appif}).
Having the application interface behave like a convergence layer, allows routing
schemes to treat local receives in the same way as remote nodes.

Convergence layers in RDTN have two parts: interfaces and links. Interfaces wait
for peers to initiale communication. For CLs for connection-oriented protocols
like TCP, the interface opens a listening socket and waits for incoming
connections. For connection-less protocols (UDP and FLUTE) the interface is
responsible for receiving bunlde data sent by peers.

In connection-oriented CLs, links both send and receive bundle data over the
bi-directional connection. When a connection-oriented interface accepts an
incoming connection it creates a link object. Connection-less links send data to
peers. Links for outgoing (regardless of whether or not the underlying protocol
is connection-oriented) are created by configuration (see section
\ref{sec.config}), from the interactive mode (see section
\ref{sec.interactive}), or as a reaction to detecting a neighbor (see section
\ref{sec.discovery}).

RDTN has three opening policies for links: always on, on-demand, and
opportunistic. The first two types can only be created from the
configuration or from the interactive mode. Always on links are opened as soon
as they are created and are only closed only in case of errors. On-demand links
are not created before a routing algorithm tries to sent data over them and they
are closed by the contact manager as soon as they are no longer needed.
Opportunistic links are created when a connection-oriented interface accepts an
incoming connection, or when the neighbor discovery detects an opportunity for
establishing a link to a peer.

Links and interfaces all have a symbolic name, which can be used to identify an
object in the configuration and the interactive mode. These names are only valid
within a single RDTN process, they cannot be used after restaring RDTN.

The state of a link is signaled to other components using the event dispatcher
described in section \ref{sec.arch}. When a link object is created it dispatches
a {\tt :linkCreated} event informing the system of the link's existence. This
event does not mean that the link is ready for communication, only when the {\tt
:linkOpen} event is dispatched, data can be sent over that link. TCP links
signal their opening, when the initial handshake specified in \cite{dtn-tcp-cl} is
completed. The UDP and FLUTE CL dispatch this event, when a socket was created
and the destination (host and port) has been specified.

When a link or interface receives data, it dispatches the {\tt :bundleData}
event, which contains a reference to the link itself and to a queue where the
incoming data can be read. This event does not signal that the data of the
bundle has be received completely, because convergence layers are not
necessarily aware of the structure of the data the receive. Determining the
boundaries of the bundle is the task of the bundle parser, the convergence layer
only parses the data relevant to its own protocol. The bundle parser must be
able to handle a bundle being received in chunks with multiple events sent by
the CL.

When a link is closed, it signals the {\tt :linkClosed} event to the rest of the
system, so that no more data can be sent over this link. Links can be closed
from the interactive mode (see section \ref{sec.interactive}) or in case of an
error. Additionally, opportunistic and on-demand links are closed by the contact
manager when their are no longer needed.

\section{Bundle Processing}\label{sec.bundle-proc}

RDTN bundle objects are implemented by {\tt Bundling::Bundle}. The objects
contain a list of Bundle blocks, the first of which is always the primary bundle
block (implemented by {\tt Bundling::PrimaryBundleBlock}). The list of blocks
also contains an arbitrary number of objects derived from {\tt Bundling::Block},
which includes the payload block ({\tt Bundling::PayloadBlock}). The blocks
contain all the data that is passed over the network between bundle agents. 

In addition to the protocol data in the blocks the bundle class holds
information for the internal processing of bundles which is not passed to other
nodes.  Bundle objects have a flag indicating whether custody was accepted for
the bundle, a custody timer, and a log of the forwarding operations performed on
this bundle.

The bundle and block classes implement parsing from and serialization to the
wire format of bundles specified in RFC 5050 \cite{bundle-spec}. Parsing is
implemented using the generic parser described in section \ref{sec.genparser}.
The order of processing steps from receiving and parsing to forwarding is
determined by the {\em bundle workflow} (see section \ref{sec.workflow}).

\subsection{Bundle Blocks}\label{sec.bundle-blocks}

As the bundle is mainly a collection of blocks, the largest part of the
implementation is located in the block classes. The primary bundle block
contains the basic information needed to route bundles to their destinations,
such as the source and destination endpoint identifiers, bundle lifetime, and
processing control flags. As these values are often accessed by RDTN components,
the Bundle class provides a convenience short-cut for accessing the fields of
the primary bundle block. So instead of retrieving the destination EID of a
bundle by calling

{\tt bundle.blocks[0].srcEid}\\
the value can be accessed by calling

{\tt bundle.srcEid}.

Likewise, the Bundle class implements a method payload which retrieves the data
from the payload block without requiring the calling code to find the block
itself.

All blocks except for the primary block, follow a canonical format defined in
section 4.5.2 of RFC 5050 \cite{bundle-spec}. Parsing this format and the common
processing flags are implemented as subclasses of Bundling::Block.
Bundling::PayloadBlock is a subclass of Block implementing the container format
for the application data transported by the bundles.

All further block-types are optional and commonly named {\em extension bundle
blocks}. RDTN implements the MetadataBlock specified in \cite{metadata-block}.
Additional blocks can be implemented as extensions to RDTN as described in
section \ref{sec.extending}.

\subsection{The Forwarding Log}\label{sec.forward-log}

Each bundle in RDTN has exactly one forwarding log. The forwarding log holds
information to keep track of when bundles are received and sent by an RDTN node.
It is implemented by {\tt Bundling::ForwardLog}, storing an entry for each time
the bundle is received, transmitted, or a transmission error for the bundle is
detected. An entry comprises of a timestamp, the action performed on the bundle,
the status of the action, and a reference
to the neighbor involved in the operation (i.e. the receiver or the sender
depending on the action).

The action is one of the following:
\begin{description}

\item[received] The bundle was received from another bundle protocol agent or
the local application interface (see section \ref{sec.appif}). An entry with
this action is always the first entry in a forwarding log.

\item[replicated] The bundle was sent to another bundle protocol agent, and the
local node keeps the bundle and can send further replicas to other nodes. This
action is used by routing schemes in which multiple copies of a bundle traverse
the network to increase the chances for successful delivery to the destination.

\item[forwarded] The bundle was sent to another bundle protocol agent, and the
local node will not send any further copies to other nodes. This action is
employed in routing schemes that allow only a single copy of the bundle in the
network.

\end{description}

The status of an action may be:
\begin{description}

\item[in-flight] The action has been started, but the RDTN instance has not
received any indication of the action's success. An entry with this status gets
updated when RDTN determines success or failure of the action.

\item[transmitted] The action was successfully completed. How success is
determined depends on the configuration. If a convergence layer is used that
provides acknowledgments, it can function as an indicator of success. Otherwise
RDTN waits for bundle status reports before setting this status.

In some configurations (i.e. when status reports are disabled and the
convergence layer does not provide acknowledgements) bundles remain in the
in-flight status indefinitely. In such configurations only routing protocols
that do not depend on explicit success indications should be used.

\item[transmission error] The action failed. The bundle will be kept and can be
re-transmitted, even if the action is forward.

\end{description}

\subsection{Bundle Workflow}\label{sec.workflow}

After a bundle is received by a convergence layer, it is taken through a
{\em workflow} for processing steps that are managed by an object of the class
Bundling::BundleWorkflow. The workflow object is notified of new data from the
CLs by the event dispatcher initiating one workflow per bundle.

As the convergence layers only deliver the raw data, the first step in the
workflow is to {\bf parse} the bundle data.  When parsing a stream of input
data, the code in the bundle class detects the type of the block at the current
position in the stream and delegates the parsing process the appropriate block
class. The block parser reads the data for a single block and hands back control
to the bundle class updating the current position in the stream to point to the
next byte after the block. This process continues until the last block has been
parsed (a flag in the block data indicates which block is the last one) or an
error occurs. If a bundle was not completely transmitted the parsing process is
suspended until the rest of the data is delivered by the convergence layer.

After that, the bundle is {\bf stored} in persistent memory. If the incoming
bundle is a fragment of a larger bundle and other pieces of that bundle are
available, the parts are {\bf reassembled}. {\bf Custody signals} and other {\bf
administrative records} are handled next if necessary. The final step is to
notify the routing implementation via the event dispatcher that the bundle is
{\bf ready to be forwarded}.

\subsection{Fragmentation and Reassembly}\label{sec.frag}

A bundle can be fragmented to accommodate transmissions of payloads that are too
large to be reliably transmitted over a single contact. RDTN allows bundles to
be broken into an arbitrary number of fragments, each of which is itself a valid
bundle. 

When a bundle is a fragment, there is a flag set in the primary bundle block and
the primary block contains a field that holds the number of bytes of the
original payload that comes before the data in the fragment's payload -- the
{\em fragment offset}. Apart from the fragment flag and offset fields, the
primary bundle block of the fragment is identical to that of the original
bundle. A bundle may be broken into fragments, even if it is already a fragment.
The fragment offset is calculated relative to the original fragment offset, so
that the offsets in all fragments are unambiguous.

RDTN can only reassemble to consecutive fragments, there must not be a gab
between the end of the first fragment and the beginning of the second one to
reassemble them. It is, however possible to reassemble only a part of the
fragments of a bundle, so that the complete bundle can be recreated in several
steps, even on different hosts.

\section{Contact Management}\label{sec.contact-mngt}

The contact manager is the component in RDTN that tracks the currently available
links and establishes new links or restarts old ones if there are contact
opportunities. It also has the housekeeping function of closing links and
interfaces that are no longer needed or stopped working. Contact management is
implemented by the class {\tt ContactManager}.

The contact manager maintains a list of all available links with their
convergence layer type and their opening policy (on-demand, opportunistic, or
always on as described in section \ref{sec.cl}). The contact manager also maps
which links are connected to which neighbor nodes. Other components can use the
contact management to resolve link names and remote EIDs to link objects. For
example, routes can be configured by specifying the destination EID and either
the name of a link over which the bundles for that destination should be
forwarded, or the EID of an intermediate bundle router. When the routing
component needs to use such a route, it asks the contact manager to return the
appropriate link object.

When the {\tt :linkCreated} is dispatched the ContactManager inserts a new Link
object to its internal list.  On {\tt :linkClosed} the respective link object is
removed from the internal list. The mapping between a link and its corresponding
neighbor EID is created, when the contact manager receives the {\tt :linkOpen}
event. That events also causes the contact manager to dispatch the {\tt
:neighborContact} and {\tt :routeAvailable} events that are used by routing
algorithms, to determine that a new neighbor is ready to receive bundles.

\subsection{Contact Opportunities}

Finding opportunities is the task of the discovery mechanisms described in
section \ref{sec.discovery}.  When a new opportunity is available, the Discovery
module dispatches a {\tt :opportunityAvailable} event which the contact manager
subscribes.

An opportunity event contains the type of the convergence layer, the remote EID
if it is available, and CL-specific parameters (hostname or IP address and a
port number in the case of TCP and UDP).

On the {\tt :opprtunityAvailable} event, the contact manager searches its
internal structures for an existing link or interface that matches the
parameters of the opportunity. If an existing one is found that is currently
inactive, the contact manager tries to restart it. If no existing link or
interface is available, a new one is created according to the parameters of the
opportunity.

\subsection{Housekeeping}

The ContactManager regularly\footnote{The interval is configurable with a
default value of five minutes.} queries all on-demand and opportunistic links if
they are currently performing a task (sending or receiving). If not, the contact
manager closes the links.  The housekeeping function runs in a separate thread
that is started when the contact manager is initialized.

\subsection{Neighbor Discovery}\label{sec.discovery}

Neighbor Discovery has the purpose to detect other bundle routers and announce
the presence of the local bundle router. If another router is found, the
discovery module dispatches an event that allows RDTN to create a link.

The initial version of neighbor discovery in RDTN uses UDP multicast to send and
receive announcements. This is compatible with the neighbor discovery in the
DTN2 reference
implementation.\footnote{http://www.dtnrg.org/wiki/NeighborDiscovery} 

{\bf TBD: Description of the Avahi stuff}

The neighbor discovery module has two parts, the announcer and the receiver. The
announcer part sends beacons for all configured interfaces in regular intervals,
the receiver waits for incoming announcements from other bundle routers. When an
announcement is received, the receiver part dispatches an event.

Announcer and receiver each run in their own threads, the receiver blocks in
reading from its socket and the announcer sleeps most of the time and
only wakes up in certain intervals to send out the announcements.

The discovery module can be configured from the RDTN config file with the
following commands:

\begin{verbatim}
  discovery :address ADDR :port PORT :interval INTERVAL
  discovery :announce INTERFACES
\end{verbatim}

The first command configures the multicast address and the port used by both
announcer an receiver. It also configures the interval between the
announcements.  The second command configures the interfaces that should be
announced.  {\tt INTERFACES} is a list of strings which identify previously
configured interfaces.

When the receiver gets an announcement, it dispatches an {\tt
:opportunityAvailable} event with the convergence layer type, the address and
port of the remote interface, and the endpoint identifier of the remote bundle
router.

RDTN neighbor discovery uses the message format from the DTN2 reference
implementation ({\tt DTN2/servlib/discovery/IPDiscovery.h}).

\begin{verbatim}
  u_int8_t cl_type;         // Type of CL offered
  u_int8_t interval;        // 100ms units
  u_int16_t length;         // total length of packet
  u_int32_t inet_addr;      // IPv4 address of CL
  u_int16_t inet_port;      // IPv4 port of CL
  u_int16_t name_len;       // length of EID
  char sender_name[0];      // DTN URI of beacon sender
\end{verbatim}

\section{Routing}\label{sec.routing}

RDTN facilitates the development and evaluation of experimental routing
algorithms by providing a basic forwarding logic which can be extended by
routing implementations. The current version of RDTN includes two concrete
routing schemes: a static table-based router and an implementation of the DTN
Publish/Subscribe protocol (DPSP) \cite{dtn-pubsub} which also supports epidemic
routing \cite{epidemic}.

The basic forwarding logic is implemented in the {\tt Router} class from which
the concrete implementations are derived. Forwarding is implemented in the {\tt
doForward} method which takes a bundle, a list of links, and an action type
identifier as parameters. The forwarder ignores a link, if the neighbor node
that is the remote end of that link has already seen the bundle. Whether a
neighbor has seen a bundle is determined by inspecting the bundle's forward log
to see, if the bundle was received from the link's peer if it was forwarded
to the peer before. As this mechanism works only on local forwarding data, it
cannot detect routing loops involving more than two peers.  More general loop
detection must be provided by the concrete routing schemes if it is required.

The forwarder adds an entry to the forward log of the bundle that contains the
status {\tt :inflight} and the action that the concrete routing scheme passed to
the forwarding function. Then the {\tt sendBundle}-function of the link object
is called. If an error occurs in this call, the new forward log entry is updated
to an error status. The concrete router implementation has to decide how this
state is handled. When the convergence layer does not raise an error, the
forwarder dispatches the {\tt :bundleForwarded} event.

\subsection{Static Routing Tables}\label{sec.static-routing}

The default routing scheme of RDTN is a static table-based routing which is
ideal for small deterministic scenarios, but it becomes impractical when the
scenarios become larger and more dynamic.

Routes can be set when the router receives the {\tt :routeAvailable} event which
is dispatched by the configuration file parser, by the interactive mode, and by
the contact manager.  An entry in the routing table contains the destination
which may be a regular expression matching multiple EIDs and either the name of
a link or an EID. If the second part is a link, all bundles whose destination
EID matches the destination part of the entry are forwarded over that link. If
the second part of the entry is an EID, the matching bundles are forwarded to
the neighbor with that EID. As this is recursive, there must be at least one
destination that is mapped to a link and not to another EID, otherwise no bundle
will ever be forwarded.

The static router always uses the {\tt :forward} action, which means that it
passes each bundle to at most one neighbor. It does not replicate bundles in the
network.

When the static router receives the {\tt :bundleToForward} event, it searches
for a routing table entry that matches the bundle's destination and forwards it.
On {\tt :routeAvailable} the router searches the persistent storage for bundles
that match the new entry's destination and forwards the bundles that are found.

\subsection{Priority-based Routing}\label{sec.prio-routing}

A more flexible router that we have implemented in RDTN is the {\tt
PriorityRouter} which implements an optimized flooding scheme. A set of
priorities and filters as defined by the DTN Publish/Subscribe Protocol (DPSP)
can be configured for this router. When no priorities or filters are used, the
router falls back to epidemic routing.

The priority-based router maintains a queue for each active contact. When DPSP
is used, the first step after the router received the {\tt :neigborContact}
event and created the queue, is to exchange a list of subscriptions as described
in \cite{dtn-pubsub}. After that, the queue is filled with all bundles from the
persistent storage. The queue is then run through all filters and the remaining
bundles are sorted based on the priorities. When more than one priority is
configured, the sorting uses a majority vote. That means, when comparing two
bundles A and B, their relative priority is assessed by each configured priority
algorithm. When more algorithms assign a higher value to A, then A gets a higher
total priority. When A is rated higher than B exactly as often as B is rated
higher than A, their total priorities are equal.

Next, the router forwards the bundles from the queued starting with the one with
the highest priority by passing each bundle to the forwarding function of the
basic router described above. The priority-based router uses the {\tt
:replicate} action, so that multiple copies of a bundle can exist in a network.
After the bundle was forwarded it is deleted from the queue. When a {\tt
:bundleToForward} event is received, the new bundle is added to all active
queues which are passed through the filters and sorted again before commencing
to forward bundles.

While the static router treats local registrations like links to remote peers,
the priority-based router maintains a separate list of local links that get only
those bundles that match the registration.

\section{Persistent Storage}\label{sec.storage}

RDTN implements its persisten storage using the Ruby {\tt PStore}.
Bundles are the most important objects the store needs to take care of, but
it also makes persistent copies of routing state (e.g. routing
tables or history of previous contacts) and link configurations.

The storage object starts a thread on initialization that searches
for expired bundles. Such bundles are deleted and the appropriate administrative
records and custody signals are generated.

{\bf deletion}

\section{Application Interface}\label{sec.appif}

The RDTN application interface allows applications to send and receive bundles,
query the persistent storage, and send application acknowledgements. This
interface can be accessed inside the RDTN daemon process, so that it can be used
by the interactive mode (see section \ref{sec.interactive}) and by extensions
(see section \ref{sec.extending}), as well as from separate processes either on
the same machine or on another one connected via a network.

\subsection{Bundle Objects}\label{sec.bundle-obj}

Applications can use the internal representation of bundles directly so that
they can manipulate all fields, flags, and extension blocks. Opening the
internal representation to applications lets us avoid the overhead of mirroring
functionality and interfaces from internal to public interfaces and it gives
applications the ability to use parts of the bundle (e.g. extensions) that are
not explicitly handled by RDTN.

However, the small overhead and high flexibility of using the internal bundle
objects comes with the risk of complicating application development by forcing
developers to deal with an abundance of options and corner cases unnecessary for
typical use cases. Incorrect use of this interface which allows access to
fundamental parts of the protocol implementation may also cause invalid messages
to be sent over the network.

The complexity of the interface is mitigated by using default values covering the
typical use cases. Thus, application developers do not need to know the details
of the bundle protocol to use the API. But it is still possible to leverage
knowledge about the protocol and possibly extensions to implement more advanced
functionality.

\subsection{Sending Bundles}\label{sec.sending}

RDTN provides two functions for sending bundles: {\tt sendBundle} and {\tt
sendDataTo}. The first function takes a bundle object, performs sanity checks
and passes it to the router as incoming bundle. The second function takes the
payload, the destination EID, and optionally the source EID and creates a new
bundle object which is passed to the router.

For either function RDTN expands the source EID if it is not a valid URI. In
that case the given string is taken as an application tag which is suffixed to
the local EID. For example, when the local EID configured for RDTN is {\tt
dtn://test.dtn/} and a sending function is called with the source EID {\tt app},
then RDTN expands this identifier, so that the source EID of the new bundle is
{\tt dtn://test.dtn/app}. If the source EID parameter is empty, the local EID is
used to fill this field.

\subsection{Receiving Bundles}\label{sec.receiving}

An application has to {\em register} itself with RDTN if it wants to receive bundles using
the {\tt register}-function. A registration is always bound to an EID.
Applications can register for any EID independent of the local EID of the RDTN
instance.

When a registration is added, RDTN passes all stored bundles matching the
registered EID to the application. After that, whenever RDTN receives a bundle 
matching the registered EID, the application gets the bundle until the 
registration is cancelled.

The call to {\tt register} is not followed directly by a response. The
application gets the bundles asynchronously. For applications written in Ruby,
the {\tt register}-function takes a block which is called for each received
bundle matching the registration.

When the application has received a bundle, it can generate an {\em application
acknowledgement} that is sent to the bundle's source. Such a message can be
generated using the {\tt applicationAck}-function.

\subsection{Interactive Mode}\label{sec.interactive}

While the default setup is to have the RDTN daemon and the applications run in
different processes, having both run in one process is helpful for testing and
debugging purposes. This is especially true, for interactively working with
RDTN. 

RDTN can be used interactively simply by loading the daemon as a module in
Ruby's interactive interpreter irb. {\tt irb -r lib/daemon.rb}

{\bf TBD: installation for RDTN so we get the paths right.}

An interactive RDTN session with irb automatically creates a Daemon object (an
instance of the class {\tt RdtnDaemon::Daemon}) which is assigned to the global
variable {\tt \$daemon}. This object can be used to send bundles (see section
\ref{sec.sending}, register for receiving bundles (see section
\ref{sec.receiving}), and to manipulate the daemon's configuration. No
configuration file is read when an interactive session is started. Instead the
daemon uses a default configuration without convergence layer and with a static
table based router. When a configuration file is needed, it can be loaded
using the {\tt parseConfigFile}-function. Routing configuration, convergence
layers, storage settings, and discovery modules (see section
\ref{sec.contact-mngt}) can be manipulated through the daemon object.

An example session which sends a bundle to itself could look like this:

\begin{verbatim}
> $daemon.register("dtn://rdtn/test") do |b|
*   puts "Received: #{b.payload} from #{b.srcEid}"
> end
=> [#<Proc:0xb7ba44a8@./lib/routetab.rb:37>]
> $daemon.sendDataTo("Hello, rdtn!", "dtn://rdtn/test",
*                    "dtn://rdtn/sender")
Received: Hello, rdtn! from dtn://rdtn/sender
\end{verbatim}

\subsection{The RDTN Client Protocol}\label{sec.client-protocol}

The RDTN client protocol allows applications running in processes separate from
the daemon to use the application interface. We anticipate that most
applications will run on the same device as the daemon, but the interface can be
used over a network, as it is based on TCP. The application interface is,
however, not intended to be used over a challenged network, so the connections
are expected to be stable and have short round-trip times. A use case for
distributed applications is a vehicular network, where an RDTN router is
installed in a vehicle to handle communications in the challenged environment
while the vehicle is moving. Other devices in the vehicle can run the
applications which use the RDTN daemon.

The client protocol is designed with three goals in mind: language-independence,
straight-forward integration with the Ruby code of the daemon, and efficient
handling of large binary payloads. 

{\bf TBD: extend this part, when the YAML stuff is implemented.}

The protocol has two categories of messages: Requests sent from client to the
daemon that directly responds, and asynchronous messages from the daemon to the
client. Asynchronous messages are solicited by a request from the client. The
functions of the application interface described in sections \ref{sec.sending}
and \ref{sec.receiving} are mapped to requests of the client protocol. In
addition to these, the protocol provides requests to get a list of bundles from
the persistent storage and to delete bundles.

All messages of the client protocol have a message type, a message id, and a
number of type-specific arguments. The message type of requests maps to the name
of the corresponding function in Ruby's symbol notation (i.e. request
corresponding to the function {\tt sendDataTo} has the type {\tt :sendDataTo}).
A message from the daemon which contains bundles has the type {\tt
:bundles}. And responses for requests that solicit asynchronous messages get
responses with the types {\tt :ok} and {\tt :error} on success or failure
respectively.

The message id is created by the client and must be unique for all requests
during a connection with the daemon. Responses have the same message id as the
corresponding request. An asynchronous message has the same message id as the
request that solicited it. E.g., the client registers for receiving bundles with
a message type {\tt :register} and the message id {\tt 1}. The daemon responds
with an {\tt :ok}-message which also has the message id {\tt 1}. When a bundle
matching the registration arrives, the daemon sends a {\tt :bundles}-message,
again with message id {\tt 1}.

The arguments of the request are the same as for the functions. The {\tt
:ok}-message has no arguments, {\tt :error} is accompanied by an error message,
and messages of type {\tt :bundles} have a list of bundles as their arguments,
even when there is only a single bundle.

{\bf TBD: encoding}.

The daemon-side of this protocol is implemented in the classes {\tt
AppIF::AppInterface} and {\tt AppIF::AppLink}. The objects of the former class
wait for incoming connections and create objects of the latter class when a
client connects. {\tt AppIF::AppLink} instances handle the communication with
one client each, relaying requests between the client to the daemon's internal
interface.

\section{Configuration}\label{sec.config}

An settings for an RDTN node can made a configuration-file using Ruby commands
similar to those available in the interactive mode. By default, this file is
located in the lib subdirectory of the RDTN path, but different locations for
the configuration may be specified on the command line.

Internally, RDTN stores its configuration in an object of the class
RdtnConfig::Settings which is passed to all components in the node that require
access to the values. The settings can be accessed either through the
configuration file or through the daemon object in interactive mode (see section
\ref{sec.interactive}). The configuration file is loaded into the Ruby
interpreter in the context of the RdtnConfig::Reader class, where values for
storage, discovery, routing, links and interfaces are passed to the settings
object or initializing the appropriate objects (e.g. convergence layers).

\section{Simulations}\label{sec.sim}

RDTN includes a module for discrete event simulation ({\bf TBD: cite}). This
module allows us to evaluate the performance of distributed algorithms (e.g.
routing schemes or DTN custody transfer) and to test their implementation. The
simulation module can be used for the functionality included in RDTN
directly as well as for extensions (see section \ref{sec.extending}).

The central component of the simulation module is the node. Each node is an
instance of the RDTN code, all running in the Ruby interpreter. Despite running
in one process, the nodes are independent, because each uses its own {\tt
EventDispatcher} (the mechanism which the RDTN components use to communicate
with each other, described in section \ref{sec.arch}). The only communication
between the simulated nodes is handled by convergence layers as it is for
``real'' nodes connected over a network. The simulated convergence layer links
are created and destroyed depending on the state of the simulated network.

Nodes are implemented by the class {\tt Sim::Node} which is derived from {\tt
RdtnDaemon::Daemon}, the class for ``real'' nodes. Because of this derivation,
the node automatically has the main components of an RDTN instance: an {\tt
EventDispatcher}, a configuration object, persistent storage, and routing
algorithms. In addition, simulation node objects have an interface for the
simulation convergence layer so that other nodes can connect.

Although the simulation could use a convergence layer that also works over a
network such as the TCP or UDP convergence layers, we implemented a
simulation-specific convergence layer that passes bundles from one node to
another by copying them in memory. This allows us to control the transmission
behaviour (e.g. applying rate limits) and we can avoid finding available ports
on the simulation host machine. The simulation convergence layer has
the distinction between link and interface used by all convergence layers (see
section \ref{sec.cl}) and is implemented in {\tt Sim::MemoryLink} and {\tt
Sim::MemoryInterface}.

Nodes and the links between them are managed by the simulation core implemented
in {\tt Sim::Core}. The core is also responsible for configuring and starting a
simulation run. The core has its own {\tt EventDispatcher} which is independent
of the dispatchers used by the nodes. The simulated network is modeled by a
sequence of connection and disconnection events. These events can come from
different sources such as parsers for mobility traces or from graph objects that
define nodes as vertices and links as edges.

To run a simulation, the core starts a {\em timer engine} that sends clock ticks
over the core's event dispatcher. The clock ticks trigger the connection and
disconnection events that are also distributed by the dispatcher and to which
the core reacts be creating or destroying convergence layer links between the
nodes. The timer engine can optionally run in real-time mode so that ticks of
the simulator clock correspond to a fixed period of time on the host machine's
system clock. Otherwise, the events are processed as fast as possible so that
the available capacity of the host CPU is the delimiting factor for the duration
of the simulation. As a consequence, the time that passes on the system clock
between two simulation clock tick is not necessarily constant.

All time-dependent functions in RDTN (e.g. removing expired bundles) use the
time of from the timer engine when run in simulation mode.  The time of the
clock ticks is always counted from zero, so that connectivity events are always
triggered at the same time in a simulation regardless of the system time.
However, for the RDTN functions, the time is calculated depending on the start
time of the simulation so that the values are in the same order of magnitude as
the system time.\footnote{This is relevant for RDTN as a time value of zero in
Ruby on Unix systems (the format RDTN uses internally) means the start of the
year 1970, while for the DTN bundle protocol a time value of zero means the
start of the year 2000 and negative values are not allowed, so that an internal
time value of zero cannot be encoded in bundles.}

In a simulation starting on 2-25-08 at 10:00, for example, the clock tick
with the value $60$ sets the internal clock of all simulated nodes to 2-25-08
10:01. Unless used in real-time mode, the simulation clock runs faster than the
system clock, so that clock tick $60$ could happen at 10:00:10.

The RDTN simulation module contains a parser for mobility traces in the format
used as input for the ns2 network
simulator.\footnote{http://www.isi.edu/nsnam/ns/} Parsers for other formats are
planned as well and are easy to implement. All sources of connectivity events
use a common target format implemented by {\tt Sim::EventQueue}. Objects of this
class store a list of events, where an event is characterized by the time when
the event happens, a pair of node identifiers, and the type of the event (i.e.
connect or disconnect). The first node identifier refers to the node initiating
a link to the node identified by the second one. When using the event queue for
simulation, the events must be ordered by their time starting with the first
event.

While input from trace parsers is necessary to simulate realistic networks of
any complexity, simpler scenarios are often useful in the first stages of
developing and debugging an algorithm. Such networks can be modelled using
objects of the class {\tt Sim::Graph}. A graph can be constructed by adding any
number of edges. An edge is a bi-directional link between two nodes and has
optionally a start and an end time. Graph objects can be used as event source
for simulations.

\section{Extending RDTN}\label{sec.extending}

\section{Conclusions}\label{sec.conclusions}

In this technical report we presented RDTN and explained its design, its
components, and how it can be used as a research platform. The flexible,
light-wieght architecture and the use of a dynamic programming language allows
for rapid development for extensions that implement proposed research protocols.
The integrated simulator allows researches to test their proposal quickly and
adapt them accordingly. It is even possible to use a testing framework such as
the Ruby's unit tests, to continually verify the functionality of the
extensions.

As future work, we are planning to work on running RDTN on mobile devices such
as cell phones and embedded routers, implementing reactive fragmentation of
bundles and the bundle security specification \cite{bundle-security}, and to
improve the performance of RDTN.

Porting RDTN to mobile devices requires us to find a Ruby interpreter that runs
on these. As many operating systems for cell phones provide a Java Virtual
Machine, JRuby\footnote{http://www.jruby.org/} an implementation of the Ruby
lagnuage in Java is a likely candidate for this project. However, the different
implementations of Ruby are not entirely compatible yet and currently RDTN only
works with version 1.8 of the reference implementation which is often referred
to as {\em MRI}.

Reactive fragmentation of bundles allows a bundle protocol agent to split a
bundle into fragments after a transmission broke off and only a part of a bundle
reached the other node. Without fragmentation the whole bundle would need to be
re-transmitted on the opportunity. With reactive fragmentation only the 
part that was not transmitted needs to be sent, thus saving bandwidth.

As RDTN is essentially a research platform, simple solutions were preferred over
optimizations during the initial development. However, in the future we will
work on improving RDTN's performance so that it can be used even on slow mobile
devices.

Although RDTN is still under development, it is already usable for research
purposes and has been used for evaluations in research papers.  In \cite{nsdr07}
we evaluated the effectiveness of a unidirectional convergence layer implemented
for RDTN and in \cite{dtn-pubsub} we used RDTN to implement and simulate our DTN
Publish/Subscribe routing scheme.

\bibliography{rn}

\end{document}
