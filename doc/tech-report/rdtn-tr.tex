\documentclass{article}

\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{times}

\bibliographystyle{plain}

\begin{document}

\title{RDTN: A DTN Bundle Protcol Agent implemented in Ruby}

\author{Janico Greifenberg \and Dirk Kutscher}
\date{\$Date: 2008-02-19 11:56:03 +0100 (Tue, 19 Feb 2008) \$\\
\$Rev: 535 \$}

\maketitle

\begin{abstract}

RDTN is a DTN bundle protocol agent (BPA) implementation written in Ruby. RDTN
is light-weight and flexible so that it can be used in DTN application and
protocol development as well as in research of DTN-related topics such as
routing or convergence-layers. 

RDTN provides a language-independent interface for client application, an
interactive environment for tests and a simulation mode for running multiple
instances of the RDTN code in a simulated network environment. RDTN implements
the bundle protocol (RFC 5050), convergence-layer adapters for TCP, UDP, and
FLUTE, and static and epidemic routing as well as the DTN Publish/Subscribe
Protocol (DPSP).

\end{abstract}

\section{Introduction}\label{sec.intro}

\section{Architecture}\label{sec.arch}

We designed the RDTN architecture with the goal to create a platform for DTN
research. That means, we want a simple implementation of the bundle protocol
which can be easily and quickly extended for experiments of DTN-related research
topics from convergence layers to applications. Another goal for RDTN is to make
it usable, robust, and portable so that it can be used in field tests of DTNs
with actual mobile devices.

RDTN is not supposed to be a reference implementation of the DTN bundle
protocol, the aspect of extensibility and easy experimentation is more important
in its design than the completeness of the protocol implementation.

The fundamental design choice for RDTN is the choice of
Ruby\footnote{http://www.ruby-lang.org} as implementation language. Ruby is a
dynamic programming language that allows simple and concise solutions to a wide
range of programming problems. As Ruby programs do not have to be compiled
explicitly before running them, extensions can be added by simply loading
additional code into an RDTN process. Thus, RDTN does not require a mechanism
for attaching extension in external processes. The dynamic type system allows
extensions a greater flexibility than a static system would.

{\bf TBD Examples}

Another central concept of RDTN's design is the loose coupling of its
components. The term component in case refers to conceptual units of RDTN, e.g.
routing, persistent storage, or convergence layers. A component may be realized
in different classes that can be complementary (such as convergence layers for
TCP and UDP) or exclusive (such as implementations of different routing
protocols). When the state of a component changes in such a way that is relevant
to other components (e.g. a convergence layer detects that the connection to
another bundle router is broken), it creates an event that is broadcast to all
interested in this incident (e.g. a lost link can be relevant for the contact
management and routing components). The component sending an event does not need
to know which components are interested in the event. A convergence layer, e.g.,
does not need a reference to the routing algorithm currently used.

Events are distributed between the components by an event dispatcher. This
functionality is implemented in the class {\tt EventDispatcher}. An RDTN bundle
router has one instance of this class and all components have a reference to it.
The event dispatcher implements a simple mechanism for sending named events and
subscribing to them.  This event mechanism allows extension to to notified of
the state of any component without the component being aware of the extension.

An event is identified by a Ruby symbol. The event dispatcher uses this
identifier to map an event to all subscribing components. Events can have
arbitrary arguments, which the dispatcher passes indiscriminately from source to
sink.

When a component subscribes to an event, it passes the event identifier and a
Ruby block to the event dispatcher. Each time the event is triggered, the event
dispatcher, executes the block, passing all the event's parameters.  The event
dispatcher does not implement any threading behaviour itself, so that event
handlers are executed in the thread in which the event was created.

RDTN uses threads to be able to handle multiple tasks that can block, such as IO
functions or timer triggered operations. Although multi-threading comes with the
risk of concurrency problems, we decided against using the {\tt select}-call for
IO multiplexing, because it is not portable. Neither did we want to use a higher
level multiplexing mechanism to avoid having any dependencies besides the Ruby
standard library. The threaded approach allows implementers of extensions to use
any scheme for multiplexing they deem appropriate as long as it is thread-save.

A new thread is started for each task that may block. These tasks include
waiting for incoming connections and data in convergence layers, sending data,
and time-triggered functions, such as deleting expired bundles.

\section{Convergence Layer Adapters}\label{sec.cl}

\section{Contact Management}\label{sec.contact-mngt}

\section{Routing}\label{sec.routing}

\section{Persistent Storage}\label{sec.storage}

\section{Application Interface}\label{sec.appif}

The RDTN application interface allows applications to send and receive bundles,
query the persistent storage, and send application acknowledgements. This
interface can be accessed inside the RDTN daemon process, so that it can be used
by the interactive mode \ref{sec.interactive} and by extensions
\ref{sec.extending}, as well as from separate processes either on the same
machine or on another one connected via a network.

\subsection{Bundle Objects}\label{sec.bundle-obj}

Applications can use the internal representation of bundles directly so that
they can manipulate all fields, flags, and extension blocks. Opening the
internal representation to applications lets us avoid the overhead of mirroring
functionality and interfaces from internal to public interfaces and it gives
applications the ability to use parts of the bundle (e.g. extensions) that are
not explicitly handled by RDTN.

However, the small overhead and high flexibility of using the internal bundle
objects comes with the risk of complicating application development by forcing
developers to deal with an abundance of options and corner cases unnecessary for
typical use cases. Incorrect use of this interface which allows access to
fundamental parts of the protocol implementation may also cause invalid messages
to be sent over the network.

The complexity of the interface is mitigated by using default values covering the
typical use cases. Thus, application developers do not need to know the details
of the bundle protocol to use the API. But it is still possible to leverage
knowledge about the protocol and possibly extensions to implement more advanced
functionality.

RDTN bundle objects are implemented by {\tt Bundling::Bundle}. The objects
contain a list of Bundle blocks, the first of which is always the primary bundle
block (implemented by {\tt Bundling::PrimaryBundleBlock}). The list of blocks
also contains an arbitrary number of objects derived from {\tt Bundling::Block},
which includes the payload block ({\tt Bundling::PayloadBlock}). Bundle objects
have a flag indicating whether custody was accepted for the bundle, a custody
timer, and a log of the forwarding operations of this bundle. The log is
implemented by {\tt Bundling::ForwardLog}, storing an entry for each time the
bundle is received, transmitted, or a transmission error for the bundle is
detected. An entry comprises of a timestamp, the action (i.e. if the bundle was
received, replicated, or forwarded), the status (i.e. transmitted, in-flight, or
transmission error), and a reference to the neighbor involved in the operation
(i.e. the receiver or the sender depending on the action).

{\bf TBD: the stuff about the forwardlog does not belong in this section}

Bundle objects can be created optionally passing payload, source EID,
destination EID, report-to EID, and custodian EID as parameters. Although the
bundle class does not save most of the values such as source, destination, and
payload itself but keeps them in the block classes, a bundle object responds
directly to function calls by delegating them to the primary bundle block object
(in the case of all fields and flags specified for that block in RFC 5050
\cite{bundle-spec}) or to the payload block. Other blocks can be accessed
through the list of blocks ({\tt Bundling::Bundle\#blocks}).

\subsection{Sending Bundles}\label{sec.sending}

RDTN provides two functions for sending bundles: {\tt sendBundle} and {\tt
sendDataTo}. The first function takes a bundle object, performs sanity checks
and passes it to the router as incoming bundle. The second function takes the
payload, the destination EID, and optionally the source EID and creates a new
bundle object which is passed to the router.

For either function RDTN expands the source EID if it is not a valid URI. In
that case the given string is taken as an application tag which is suffixed to
the local EID. For example, when the local EID configured for RDTN is {\tt
dtn://test.dtn/} and a sending function is called with the source EID {\tt app},
then RDTN expands this identifier, so that the source EID of the new bundle is
{\tt dtn://test.dtn/app}. If the source EID parameter is empty, the local EID is
used to fill this field.

\subsection{Receiving Bundles}\label{sec.receiving}

An application has to {\em register} if it wants to receive bundles using the
{\tt register}-function. A registration is always bound to an EID. Applications 
can register for any EID independent of the local EID of the RDTN instance.

When a registration is added, RDTN passes all stored bundles matching the
registered EID to the application. After that, whenever RDTN receives a bundle 
matching the registered EID, the application gets the bundle until the 
registration is cancelled.

The call to {\tt register} is not followed directly by a response. The
application gets the bundles asynchronously. For applications written in Ruby,
the {\tt register}-function takes a block which is called for each received
bundle matching the registration.

When the application has received a bundle, it can generate an {\em application
acknowledgement} that is sent to the bundle's source. Such a message can be
generated using the {\tt applicationAck}-function.

\subsection{Interactive Mode}\label{sec.interactive}

While the default setup is to have the RDTN daemon and the applications run in
different processes, having both run in one process is helpful for testing and
debugging purposes. This is especially true, for interactively working with
RDTN. 

RDTN can be used interactively simply by loading the daemon as a module in
Ruby's interactive interpreter irb. {\tt irb -r lib/daemon.rb}

{\bf TBD: installation for RDTN so we get the paths right.}

An interactive RDTN session with irb automatically creates a Daemon object (an
instance of the class {\tt RdtnDaemon::Daemon}) which is assigned to the global
variable {\tt \$daemon}. This object can be used to send bundles (see section
\ref{sec.sending}, register for receiving bundles (see section
\ref{sec.receiving}), and to manipulate the daemon's configuration. No
configuration file is read when an interactive session is started. Instead the
daemon uses a default configuration without convergence layer and with a static
table based router. When a configuration file is needed, it can be loaded
using the {\tt parseConfigFile}-function. Routing configuration, convergence
layers, storage settings, and discovery modules (see section
\ref{sec.contact-mngt}) can be manipulated through the daemon object.

An example session which sends a bundle to itself could look like this:

\begin{verbatim}
> $daemon.register("dtn://rdtn/test") do |b|
*   puts "Received: #{b.payload} from #{b.srcEid}"
> end
=> [#<Proc:0xb7ba44a8@./lib/routetab.rb:37>]
> $daemon.sendDataTo("Hello, rdtn!", "dtn://rdtn/test",
*                    "dtn://rdtn/sender")
Received: Hello, rdtn! from dtn://rdtn/sender
\end{verbatim}

\subsection{The RDTN Client Protocol}\label{sec.client-protocol}

The RDTN client protocol allows applications running in processes separate from
the daemon to use the application interface. We anticipate that most
applications will run on the same device as the daemon, but the interface can be
used over a network, as it is based on TCP. The application interface is,
however, not intended to be used over a challenged network, so the connections
are expected to be stable and have short round-trip times. A use case for
distributed applications is a vehicular network, where an RDTN router is
installed in a vehicle to handle communications in the challenged environment
while the vehicle is moving. Other devices in the vehicle can run the
applications which use the RDTN daemon.

The client protocol is designed with three goals in mind: language-independence,
straight-forward integration with the Ruby code of the daemon, and efficient
handling of large binary payloads. 

{\bf TBD: extend this part, when the YAML stuff is implemented.}

The protocol has two categories of messages: Requests sent from client to the
daemon that directly responds, and asynchronous messages from the daemon to the
client. Asynchronous messages are solicited by a request from the client. The
functions of the application interface described in sections \ref{sec.sending}
and \ref{sec.receiving} are mapped to requests of the client protocol. In
addition to these, the protocol provides requests to get a list of bundles from
the persistent storage and to delete bundles.

All messages of the client protocol have a message type, a message id, and a
number of type-specific arguments. The message type of requests maps to the name
of the corresponding function in Ruby's symbol notation (i.e. request
corresponding to the function {\tt sendDataTo} has the type {\tt :sendDataTo}).
A message from the daemon which contains bundles has the type {\tt
:bundles}. And responses for requests that solicit asynchronous messages get
responses with the types {\tt :ok} and {\tt :error} on success or failure
respectively.

The message id is created by the client and must be unique for all requests
during a connection with the daemon. Responses have the same message id as the
corresponding request. An asynchronous message has the same message id as the
request that solicited it. E.g., the client registers for receiving bundles with
a message type {\tt :register} and the message id {\tt 1}. The daemon responds
with an {\tt :ok}-message which also has the message id {\tt 1}. When a bundle
matching the registration arrives, the daemon sends a {\tt :bundles}-message,
again with message id {\tt 1}.

The arguments of the request are the same as for the functions. The {\tt
:ok}-message has no arguments, {\tt :error} is accompanied by an error message,
and messages of type {\tt :bundles} have a list of bundles as their arguments,
even when there is only a single bundle.

{\bf TBD: encoding}.

The daemon-side of this protocol is implemented in the classes {\tt
AppIF::AppInterface} and {\tt AppIF::AppLink}. The objects of the former class
wait for incoming connections and create objects of the latter class when a
client connects. {\tt AppIF::AppLink} instances handle the communication with
one client each, relaying requests between the client to the daemon's internal
interface.

\section{Configuration}\label{sec.config}

\section{Simulations}\label{sec.sim}

RDTN includes a module for discrete event simulation ({\bf TBD: cite}). This
module allows us to evaluate the performance of distributed algorithms (e.g.
routing schemes or DTN custody transfer) and to test their implementation. The
simulation module can be used for the functionality included in RDTN
directly as well as for extensions (see section \ref{sec.extending}).

The central component of the simulation module is the node. Each node is an
instance of the RDTN code, all running in the Ruby interpreter. Despite running
in one process, the nodes are independent, because each uses its own {\tt
EventDispatcher} (the mechanism which the RDTN components use to communicate
with each other, described in section \ref{sec.arch}). The only communication
between the simulated nodes is handled by convergence layers as it is for
``real'' nodes connected over a network. The simulated convergence layer links
are created and destroyed depending on the state of the simulated network.

Nodes are implemented by the class {\tt Sim::Node} which is derived from {\tt
RdtnDaemon::Daemon}, the class for ``real'' nodes. Because of this derivation,
the node automatically has the main components of an RDTN instance: an {\tt
EventDispatcher}, a configuration object, persistent storage, and routing
algorithms. In addition, simulation node objects have an interface for the
simulation convergence layer so that other nodes can connect.

Although the simulation could use a convergence layer that also works over a
network such as the TCP or UDP convergence layers, we implemented a
simulation-specific convergence layer that passes bundles from one node to
another by copying them in memory. This allows us to control the transmission
behaviour (e.g. applying rate limits) and we can avoid finding available ports
on the simulation host machine. The simulation convergence layer has
the distinction between link and interface used by all convergence layers (see
section \ref{sec.cl}) and is implemented in {\tt Sim::MemoryLink} and {\tt
Sim::MemoryInterface}.

Nodes and the links between them are managed by the simulation core implemented
in {\tt Sim::Core}. The core is also responsible for configuring and starting a
simulation run. The core has its own {\tt EventDispatcher} which is independent
of the dispatchers used by the nodes. The simulated network is modeled by a
sequence of connection and disconnection events. These events can come from
different sources such as parsers for mobility traces or from graph objects that
define nodes as vertices and links as edges.

To run a simulation, the core starts a {\em timer engine} that sends clock ticks
over the core's event dispatcher. The clock ticks trigger the connection and
disconnection events that are also distributed by the dispatcher and to which
the core reacts be creating or destroying convergence layer links between the
nodes. The timer engine can optionally run in real-time mode so that ticks of
the simulator clock correspond to a fixed period of time on the host machine's
system clock. Otherwise, the events are processed as fast as possible so that
the available capacity of the host CPU is the delimiting factor for the duration
of the simulation. As a consequence, the time that passes on the system clock
between two simulation clock tick is not necessarily constant.

All time-dependent functions in RDTN (e.g. removing expired bundles) use the
time of from the timer engine when run in simulation mode.  The time of the
clock ticks is always counted from zero, so that connectivity events are always
triggered at the same time in a simulation regardless of the system time.
However, for the RDTN functions, the time is calculated depending on the start
time of the simulation so that the values are in the same order of magnitude as
the system time.\footnote{This is relevant for RDTN as a time value of zero in
Ruby on Unix systems (the format RDTN uses internally) means the start of the
year 1970, while for the DTN bundle protocol a time value of zero means the
start of the year 2000 and negative values are not allowed, so that an internal
time value of zero cannot be encoded in bundles.}

In a simulation starting on 2-25-08 at 10:00, for example, the clock tick
with the value $60$ sets the internal clock of all simulated nodes to 2-25-08
10:01. Unless used in real-time mode, the simulation clock runs faster than the
system clock, so that clock tick $60$ could happen at 10:00:10.

The RDTN simulation module contains a parser for mobility traces in the format
used as input for the ns2 network
simulator.\footnote{http://www.isi.edu/nsnam/ns/} Parsers for other formats are
planned as well and are easy to implement. All sources of connectivity events
use a common target format implemented by {\tt Sim::EventQueue}. Objects of this
class store a list of events, where an event is characterized by the time when
the event happens, a pair of node identifiers, and the type of the event (i.e.
connect or disconnect). The first node identifier refers to the node initiating
a link to the node identified by the second one. When using the event queue for
simulation, the events must be ordered by their time starting with the first
event.

While input from trace parsers is necessary to simulate realistic networks of
any complexity, simpler scenarios are often useful in the first stages of
developing and debugging an algorithm. Such networks can be modelled using
objects of the class {\tt Sim::Graph}. A graph can be constructed by adding any
number of edges. An edge is a bi-directional link between two nodes and has
optionally a start and an end time. Graph objects can be used as event source
for simulations.

\section{Extending RDTN}\label{sec.extending}

\section{Conclusions}\label{sec.conclusions}

%\bibliography{bibtex/rn}

\end{document}
